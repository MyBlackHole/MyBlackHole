# 分组密码

分组密码，也叫块加密(Block Cyper)
一般先对明文m进行填充得到一个长度是固定分组长度s的整数倍明文串M
然后将M划分成一个个长度为s的分组；最后对每个分组使用同一个密钥执行加密变换
比较常见的算法有[[AES]]、[[DES]]、[[3DES]]

分组密码中，无论是明文块还是密文块，块与块之间都有一些逻辑运算关系，这些关系即为运算的模式。 
比较常见的分组密码运算的五种模式： 

- Electronic Code Book(ECB)电子密码本模式 
- Cipher Block Chaining(CBC)密码分组链接模式 
- Cipher Feedback Mode(CFB)加密反馈模式 
- Output Feedback Mode(OFB)输出反馈模式 
- Counter mode（CTR）计数器模式 

目前推荐使用的是CBC模式和CTR模式，其它模式较少使用或不推荐使用。 

| 模式    | 优点    | 缺点    | 备注    |
| ----- | ----- | ----- | ----- |
| ECB模式 | Item1 | Item1 | Item1 |


## ECB模式
ECB(Electronic codebook)又称电子密码本模式
    是最基本的块密码加密模式，加密前根据加密块大小（如AES为128位）分成若干块，如果最后一块不足128位，使用填充(具体看算法，默认是0x00)
    之后将每个块使用相同的密钥单独加密得到密文块，然后将密文块连在一起就得到密文了。解密同理
下图展示ECB模式加解密的过程：
![[imgs/GetImage.jpeg]]
![[imgs/GetImage 1.jpeg]]

由此得知相同的明文内容将永远加密成相同的密文，而且密文的格式和明文也相同
这是很不安全的，尤其是传输图片或明文内容重复很多的情况下
由于所有分组的加密方式一致，明文中的重复内容会在密文中有所体现，因此难以抵抗统计分析攻击
还有因为明文和密文的内容顺序一致，攻击者很容易破坏密文
攻击者在密文传输过程中截获，并对密文内容次序打乱，接收密文信息者得到的密文就不可能解密成原本的明文信息了
这也是ECB模式很少使用的原因

特点： 
1. 操作简单，易于实现，有利于并行计算，误差不会被传送； 
2. 不能隐藏明文的模式； 
3. 可能对明文进行主动攻击； 

## CBC模式
CBC(Cipher Block Chaining)又称密文分组链接模式
之所以叫这个名字，是因为密文分组像链条一样相互连接在一起。 

在CBC模式中，每个明文块先与前一个密文块进行异或后，再进行加密。在这种方法中，每个密文块都依赖于它前面的所有明文块。同时，为了保证每条消息的唯一性，在第一个块中需要使用初始化向量。 
若第一个块的下标为1
则CBC模式的加密过程为：
    Ci = Ek(P⊕ Ci-1),C0 = IV. 
而其解密过程则为： 
    Pi = Dk(Ci)⊕ Ci-1,C0 = IV.

![[imgs/GetImage 2.jpeg]]
![[imgs/GetImage 1.png]]

优点： 

1. 明文的重复排列不会反映在密文中 
2. 支持并行计算（仅解密） 
3. 能够解密任意密文分组 

缺点： 
1. 对包含某些错误比特的密文进行解密时，第一个分组的全部比特以及后一个分组的相应比特会出错 
2. 加密不支持并行计算 

## CFB模式
CFB(Cipher feedback)又称密文反馈
模式类似于CBC，可以将块密码变为自同步的流密码；工作过程亦非常相似
需要使用一个与块的大小相同的移位寄存器，并用IV将寄存器初始化
然后，将寄存器内容使用块密码加密，然后将结果的最高x位与平文的x进行异或，以产生密文的x位
下一步将生成的x位密文移入寄存器中，并对下面的x位平文重复这一过程
解密过程与加密过程相似，以IV开始，对寄存器加密，将结果的高x与密文异或，产生x位平文，再将密文的下面x位移入寄存器
与CBC相似，明文的改变会影响接下来所有的密文，因此加密过程不能并行化
而同样的，与CBC类似，解密过程是可以并行化的。 

![[imgs/GetImage 2.png]]
![[imgs/GetImage 3.png]]

优点： 
1. 不需要填充（padding） 
2. 支持并行计算（仅解密） 
3. 能够解密任意密文分组 

缺点： 
1. 加密不支持并行计算 
2. 对包含某些错误比特的密文进行解密时，第一个分组的全部比特以及后一个分组的相应比特会出错 
3. 不能抵御重放攻击 

## OFB模式
OFB：将分组密码作为同步序列密码运行，和CFB相似，不过OFB用的是前一个n位密文输出分组反馈回移位寄存器，OFB没有错误扩散问题。 
输出反馈模式（Output feedback, OFB）可以将块密码变成同步的流密码。它产生密钥流的块，然后将其与平文块进行异或，得到密文。与其它流密码一样，密文中一个位的翻转会使平文中同样位置的位也产生翻转。这种特性使得许多错误校正码，例如奇偶校验位，即使在加密前计算而在加密后进行校验也可以得出正确结果。 
每个使用OFB的输出块与其前面所有的输出块相关，因此不能并行化处理。然而，由于平文和密文只在最终的异或过程中使用，因此可以事先对IV进行加密，最后并行的将平文或密文进行并行的异或处理。 
可以利用输入全0的CBC模式产生OFB模式的密钥流。这种方法十分实用，因为可以利用快速的CBC硬件实现来加速OFB模式的加密过程。 

![[imgs/GetImage 4.png]]
![[imgs/GetImage 5.png]]

优点： 
1. 不需要填充（padding） 
2. 可事先进行加密、解密的准备 
3. 加密、解密使用相同结构 
4. 对包含某些错误比特的密文进行解密时，只有铭文中相应的比特会出错 

缺点： 
1. 不支持并行运算 
2. 主动攻击这反转密文分组中的某些比特时，明文分组中相对应的比特也会被反转 

## CTR模式
计数模式（CTR模式）加密是对一系列输入数据块(称为计数)进行加密，产生一系列的流密码，流密码与明文异或得到密文，同样解密就是流密码与密文异或得到明文。 
数据块是加密之前通过将逐次累加的计数器产生不同的比特序列，它是由nonce和counter（分组序号）构成的。CTR计数器，长度是128比特(16字节)。前8个字节是叫做nonce的初始值，这个值每次加密都不相同。后8个字节则是分组序号，也就是不断+1得到的值。nonce的作用是让数据块内容复杂化。如果没有nonce，只有counter，数据块过于单一。Golang里封装的计数器实现与这里讲的有些许不同，首先初始化一个长度为BLOCK.SIZE()的初始向量iv，然后iv最后一个字节通过计数器逐组递增，同样也会产生分组加密之前不同的数据块。 
加密的过程就是生成一个初始的计数器。假设有8个分组，就通过初始计数器不断+1得到8个计数器值，每个计数器值再加密得到密钥流，每个密钥流和对应分组明文异或得到密文。所以它的加密过程相当于一次一密。 
CTR模式中可以以任意顺序对分组进行加密和解密，因为在加密和解密时需要用到的“计数器”的值可以由nonce和分组序号直接计算出来。这就意味着能够实现并行计算。在支持并行计算的系统中，CTR模式的速度是非常快的。 
下图展示CTR模式的加解密的过程：

![[imgs/GetImage 6.png]]
![[imgs/GetImage 7.png]]

优点： 
1. 不需要填充（padding） 
2. 可事先进行加密、解密的准备 
3. 加密、解密使用相同的结构 
4. 对包含某些错误比特的密文进行解密时，只有明文中相对应的比特会出错 
5. 支持并行计算（加密、解密） 
缺点： 
1. 主动攻击者反转密文分组中的某些比特时，明文分组中对应的比特也会被反转 
2. 没有错误传播，不适合用于数据完整性认证。 
