# Erasure Code

[实现](https://github.com/klauspost/reedsolomon)

纠错码
是一种前向错误纠正技术（Forward Error Correction，FEC，说明见后附录），主要应用在网络传输中避免包的丢失， 存储系统利用它来提高 存储 可靠性。相比多副本复制而言， 纠删码能够以更小的数据冗余度获得更高数据可靠性， 但编码方式较复杂，需要大量计算 。纠删码只能容忍数据丢失，无法容忍数据篡改，纠删码正是得名与此。 

Reed-Solomon(RS)码
Reed-Solomon（RS）码是存储系统较为常用的一种纠删码，它有两个参数n和m，记为RS(n,m)。n代表原始数据块个数。m代表校验块个数。接下来介绍RS码的原理。
- RS的特点
1. 低冗余度，高磁盘利用率。
2. 数据恢复代价高。 丢失数据块或者编码块时， RS需要读取n个数据块和校验块才能恢复数据， 数据恢复效率也在一定程度上制约了RS的可靠性。
3. 数据更新代价高。 数据更新相当于重新编码， 代价很高， 因此常常针对只读数据，或者冷数据。

工程实践中，一般对于热数据还是会使用多副本策略来冗余，冷数据使用纠删码。

纠删码引擎
## RS原理
以n=5，m=3为例。即5个原始数据块，乘上一个(n+m)n的矩阵，然后得出一个(n+m)1的矩阵。根据矩阵特点可以得知结果矩阵中前面5个值与原来的5个数据块的值相等，而最后3个则是计算出来的校验块。
![[imgs/Pasted image 20231112160111.png]]

以上过程为编码过程。D是原始数据块，得到的C为校验块。

假设丢失了m块数据。如下：
![[imgs/Pasted image 20231112160126.png]]

那我们如何从剩余的n个数据块（注意，这里剩余的n块可能包含几个原始数据块+几个校验块）恢复出来原始的n个数据块呢，就需要通过下面的decoding（解码）过程来实现。

### 第一步
从编码矩阵中删去丢失数据块和丢失编码块对应行。 将删掉m个块的(n+m)1个矩阵变形为n1矩阵，同时B矩阵也需要删掉对应的m个行得出一个B'的变形矩阵，这个B'就是n*n矩阵。如下：假设D1、D4、C2丢失，我们得到如下B’矩阵及等式。
![[imgs/Pasted image 20231112160222.png]]
### 第二步
求出B’的逆矩阵。
![[imgs/Pasted image 20231112160256.png]]

### 第三步

等式两边分别乘上B’的逆矩阵。
![[imgs/Pasted image 20231112160317.png]]
B’和它的逆矩阵相乘得到单位矩阵I，如下：
![[imgs/Pasted image 20231112160326.png]]
左边只剩下原始数据矩阵D：
![[imgs/Pasted image 20231112160338.png]]
