### 描述

### 乐观锁
当一个线程需要对一个共享资源进行操作的时候,不对它进行加锁,而是在操作完成之后进行判断
- 例如
比如乐观锁会通过一个版本号控制
如果操作完成后通过版本号进行判断在该线程操作过程中是否有其他线程已经对该共享资源进行操作了
如果有则通知操作失败
如果没有则操作成功
版本号可以解决ABA[^1]问题

### 悲观锁
当一个线程需要对共享资源进行操作的时候
首先对共享资源进行加锁
当该线程持有该资源的锁的时候
其他线程对该资源进行操作的时候会被**阻塞**

### 排他锁(X锁)
数据对象被加上排它锁时,其他的事务不能对它读取和修改
- mysql InnoDB引擎默认的修改数据语句,update,delete,insert都会自动给涉及到的数据加上排他锁,select语句默认不会加任何锁类型
- 排他锁不能和其他锁共存

### 共享锁(S锁)
加了共享锁的数据对象可以被其他事务读取,但不能修改
- 共享锁可以和其他锁共存(由于排他锁的特性,共享锁只能和共享锁共存)

### 红锁(RedLock)
- 安全特性：互斥访问，即永远只有一个 client 能拿到锁 
- 避免死锁：最终 client 都可能拿到锁，不会出现死锁的情况，即使原本锁住某资源的 client crash 了或者出现了网络分区 
- 容错性：只要大部分 Redis 节点存活就可以正常提供服务 

#### 算法流程
算法很易懂，起 5 个 master 节点，分布在不同的机房尽量保证可用性。为了获得锁，client 会进行如下操作
1. 得到当前的时间,微妙单位 
2. 尝试顺序地在5个实例上申请锁,当然需要使用相同的key和random value,这里一个client需要合理设置与master节点沟通的timeout大小,避免长时间和一个fail了的节点浪费时间
3. 当client在大于等于3 个 master 上成功申请到锁的时候,且它会计算申请锁消耗了多少时间,这部分消耗的时间采用获得锁的当下时间减去第一步获得的时间戳得到,如果锁的持续时长(lock validity time)比流逝的时间多的话,那么锁就真正获取到了
4. 如果锁申请到了,那么锁真正的 lock validity time 应该是 origin（lock validity time） - 申请锁期间流逝的时间 
5. 如果 client 申请锁失败了,那么它就会在少部分申请成功锁的 master 节点上执行释放锁的操作,重置状态 

[^1]: 当一个值从A更新B,又更新回A,普通CAS机制会误判通过检测
