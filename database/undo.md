# undo

撤销

## 核心目标

事务回滚: 撤销未提交事务的修改。
多版本读一致性: 提供快照隔离(Snapshot Isolation)，避免读写冲突。
旧版本清理: 回收已失效的旧数据版本。

## 定义

undo 操作记录了事务开始前数据库的状态。
这些记录存储在撤销日志(Undo Log)中。

## 作用

事务回滚: 如果事务需要回滚，撤销日志中的记录可以用来撤销事务对数据库所做的修改。
多版本并发控制(MVCC): 在支持多版本并发控制的数据库中，撤销日志用于生成不同版本的数据，以便事务可以读取事务开始时的数据快照。

## 操作的本质

UPDATE/DELETE: 不直接修改原数据，而是插入新版本元组，旧版本通过 xmax 标记失效。
事务回滚: 只需将本事务修改的元组的 xmax 重置为 0 或删除新插入的元组。
无需独立 UNDO 日志: 旧版本数据直接存储在表文件中。


## postgresql

每个表的数据行（Heap Tuple）包含隐藏的系统字段，用于版本控制：
字段	说明
xmin	插入该元组的事务 ID（记录创建者）
xmax	删除/更新该元组的事务 ID（初始为 0，表示未删除）
ctid	当前元组的物理位置（行指针）
t_infomask	状态标志位（如元组是否已提交、是否被锁定）


```
-- 事务 T1 (ID=100) 插入数据
INSERT INTO test VALUES (1, 'A');
-- 元组结构：
xmin=100, xmax=0, ctid=(0,1)

-- 事务 T2 (ID=200) 更新数据
UPDATE test SET data='B' WHERE id=1;
-- 旧元组：xmax=200 (标记为被更新)
-- 新元组：xmin=200, xmax=0, ctid=(0,2)


graph LR
    A[事务执行ROLLBACK] --> B[遍历事务ID对应的元组]
    B --> C{操作类型}
    C -- INSERT --> D[删除新插入的元组]
    C -- UPDATE/DELETE --> E[重置旧元组的xmax=0]
    D & E --> F[释放事务锁]

场景：
  事务 T1 (ID=500) 更新一行：
    - 原元组：xmin=100, xmax=0 → 修改为 xmax=500
    - 新元组：xmin=500, xmax=0

1. 若 T1 提交：
   - 原元组 xmax=500 表示失效，新元组可见。
   - VACUUM 后续清理原元组。

2. 若 T1 回滚：
   - 新元组被物理删除。
   - 原元组的 xmax 重置为 0（恢复可见性）。
```


### 崩溃恢复期间的 UNDO

PostgreSQL 在恢复时通过 WAL 实现 UNDO:
未提交事务的 WAL 记录: 在重放 REDO 后，所有未提交的事务会被标记为终止。
VACUUM 清理: 后续由 VACUUM 进程清理这些失效元组。

元组可见 ⇔ (xmin 已提交 AND xmin < 当前快照) AND (xmax=0 OR xmax 未提交 OR xmax > 当前快照)


## 与传统 UNDO 方案的对比

特性	PostgreSQL (MVCC)	Oracle (独立 UNDO)
存储位置	表文件中（与数据共存）	独立 UNDO 表空间
回滚速度	极快（仅修改元组标记）	需从 UNDO 段重构数据
空间开销	更高（需定期 VACUUM）	更可控（UNDO 自动循环使用）
读一致性	天然支持（多版本）	需构造 CR (Consistent Read) 块
并发冲突	少（读写不阻塞）	可能遇到 ORA-01555 快照过旧



# 总结

PostgreSQL 的 UNDO 机制通过 MVCC 实现:
数据版本化: 每个修改生成新元组，旧版本保留在堆表中。
高效回滚: 回滚只需重置标记或删除新元组。
自动清理: VACUUM 回收失效版本，避免空间膨胀。
无独立 UNDO: 简化设计，但需监控表膨胀问题。

这种设计以空间换时间，提供了卓越的读写并发性能，但要求开发者理解 MVCC 并合理配置 VACUUM。

