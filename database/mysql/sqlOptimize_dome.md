### 索引失效的情况及解决
- 数据准备
```sql
MySQL root@127.0.0.1:test> CREATE TABLE `student` (
                        ->  `id` int NOT NULL COMMENT 'id',
                        ->  `name` varchar(255) COLLATE utf8mb4_bin DEFAULT NULL COMMENT '姓名',
                        ->  `age` int DEFAULT NULL COMMENT '年龄',
                        ->  `birthday` datetime DEFAULT NULL COMMENT '生日',
                        ->  PRIMARY KEY (`id`),
                        ->  KEY `idx_name` (`name`) USING BTREE,
                        ->  KEY `idx_name_age` (`name`,`age`) USING BTREE
                        -> ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;
Query OK, 0 rows affected
Time: 0.080s


MySQL root@127.0.0.1:test> INSERT INTO `student` VALUES (1, '张三', 18, '2021-12-23 17:12:44'), (2, '李四', 20, '2021-12-22 17:12:48');
Query OK, 2 rows affected
Time: 0.017s
```

1. 查询条件中有or,即使有部分条件带索引也会失效 
```sql
MySQL root@127.0.0.1:test> explain SELECT * FROM `student` where id =1;
+----+-------------+---------+------------+-------+---------------+---------+---------+-------+------+----------+--------+
| id | select_type | table   | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra  |
+----+-------------+---------+------------+-------+---------------+---------+---------+-------+------+----------+--------+
| 1  | SIMPLE      | student | <null>     | const | PRIMARY       | PRIMARY | 4       | const | 1    | 100.0    | <null> |
+----+-------------+---------+------------+-------+---------------+---------+---------+-------+------+----------+--------+

MySQL root@127.0.0.1:test> explain SELECT * FROM `student` where id =1 or birthday = "2021-12-23";  # 此时全表扫描 type = ALL,除非所有查询条件都有索引
+----+-------------+---------+------------+------+---------------+--------+---------+--------+------+----------+-------------+
| id | select_type | table   | partitions | type | possible_keys | key    | key_len | ref    | rows | filtered | Extra       |
+----+-------------+---------+------------+------+---------------+--------+---------+--------+------+----------+-------------+
| 1  | SIMPLE      | student | <null>     | ALL  | PRIMARY       | <null> | <null>  | <null> | 2    | 75.0     | Using where |
+----+-------------+---------+------------+------+---------------+--------+---------+--------+------+----------+-------------+
```

2. like查询是以%开头
```sql
MySQL root@127.0.0.1:test> explain select * from student where name = "张三";  # 命中索引 type = ref
+----+-------------+---------+------------+------+-----------------------+----------+---------+-------+------+----------+--------+
| id | select_type | table   | partitions | type | possible_keys         | key      | key_len | ref   | rows | filtered | Extra  |
+----+-------------+---------+------------+------+-----------------------+----------+---------+-------+------+----------+--------+
| 1  | SIMPLE      | student | <null>     | ref  | idx_name,idx_name_age | idx_name | 1023    | const | 1    | 100.0    | <null> |
+----+-------------+---------+------------+------+-----------------------+----------+---------+-------+------+----------+--------+


MySQL root@127.0.0.1:test> explain select * from student where name like "%三";  # type = ALL, 全表扫描
+----+-------------+---------+------------+------+---------------+--------+---------+--------+------+----------+-------------+
| id | select_type | table   | partitions | type | possible_keys | key    | key_len | ref    | rows | filtered | Extra       |
+----+-------------+---------+------------+------+---------------+--------+---------+--------+------+----------+-------------+
| 1  | SIMPLE      | student | <null>     | ALL  | <null>        | <null> | <null>  | <null> | 2    | 50.0     | Using where |
+----+-------------+---------+------------+------+---------------+--------+---------+--------+------+----------+-------------+
```

3. 如果列类型是字符串，那在查询条件中需要将数据用引号引用起来，否则不走索引
```sql
MySQL root@127.0.0.1:test> explain select * from student where name = "张三";  # type = ref
+----+-------------+---------+------------+------+-----------------------+----------+---------+-------+------+----------+--------+
| id | select_type | table   | partitions | type | possible_keys         | key      | key_len | ref   | rows | filtered | Extra  |
+----+-------------+---------+------------+------+-----------------------+----------+---------+-------+------+----------+--------+
| 1  | SIMPLE      | student | <null>     | ref  | idx_name,idx_name_age | idx_name | 1023    | const | 1    | 100.0    | <null> |
+----+-------------+---------+------------+------+-----------------------+----------+---------+-------+------+----------+--------+


MySQL root@127.0.0.1:test> explain select * from student where name = 2222  # 索引字段类型不对，type = ALL，不走索引
+----+-------------+---------+------------+------+-----------------------+--------+---------+--------+------+----------+-------------+
| id | select_type | table   | partitions | type | possible_keys         | key    | key_len | ref    | rows | filtered | Extra       |
+----+-------------+---------+------------+------+-----------------------+--------+---------+--------+------+----------+-------------+
| 1  | SIMPLE      | student | <null>     | ALL  | idx_name,idx_name_age | <null> | <null>  | <null> | 2    | 50.0     | Using where |
+----+-------------+---------+------------+------+-----------------------+--------+---------+--------+------+----------+-------------+
```

4. 索引列上参与计算会导致索引失效
```sql
MySQL root@127.0.0.1:test> explain select * from student where id-1 = 1
+----+-------------+---------+------------+------+---------------+--------+---------+--------+------+----------+-------------+
| id | select_type | table   | partitions | type | possible_keys | key    | key_len | ref    | rows | filtered | Extra       |
+----+-------------+---------+------------+------+---------------+--------+---------+--------+------+----------+-------------+
| 1  | SIMPLE      | student | <null>     | ALL  | <null>        | <null> | <null>  | <null> | 2    | 100.0    | Using where |
+----+-------------+---------+------------+------+---------------+--------+---------+--------+------+----------+-------------+
```

5. 违背最左匹配原则
```sql
MySQL root@127.0.0.1:test> explain select * from student where age =18;
+----+-------------+---------+------------+------+---------------+--------+---------+--------+------+----------+-------------+
| id | select_type | table   | partitions | type | possible_keys | key    | key_len | ref    | rows | filtered | Extra       |
+----+-------------+---------+------------+------+---------------+--------+---------+--------+------+----------+-------------+
| 1  | SIMPLE      | student | <null>     | ALL  | <null>        | <null> | <null>  | <null> | 2    | 50.0     | Using where |
+----+-------------+---------+------------+------+---------------+--------+---------+--------+------+----------+-------------+

# 正确列子
MySQL root@127.0.0.1:test> explain select * from student where age =18 and name ="张三";
+----+-------------+---------+------------+------+-----------------------+----------+---------+-------+------+----------+-------------+
| id | select_type | table   | partitions | type | possible_keys         | key      | key_len | ref   | rows | filtered | Extra       |
+----+-------------+---------+------------+------+-----------------------+----------+---------+-------+------+----------+-------------+
| 1  | SIMPLE      | student | <null>     | ref  | idx_name,idx_name_age | idx_name | 1023    | const | 1    | 50.0     | Using where |
+----+-------------+---------+------------+------+-----------------------+----------+---------+-------+------+----------+-------------+

```

6. 如果mysql估计全表扫描要比使用索引要快，会不适用索引
7. 其他

1) 没有查询条件，或者查询条件没有建立索引
2) 在查询条件上没有使用引导列
3) 查询的数量是大表的大部分，应该是30％以上
4) 索引本身失效
5) 查询条件使用函数在索引列上，或者 对索引列进行运算， 运算包括(+，-，*，/，! 等) 错误的例子：select * from test where id-1=9; 正确的例子：select * from test where id=10
6) 对小表查询
7) 提示不使用索引
8) 统计数据不真实
9) CBO计算走索引花费过大的情况。其实也包含了上面的情况，这里指的是表占有的block要比索引小
10) 隐式转换导致索引失效.这一点应当引起重视.也是开发中经常会犯的错误. 由于表的字段tu_mdn定义为varchar2(20),但在查询时把该字段作为number类型以where条件传给Oracle,这样会导致索引失效. 错误的例子：select * from test where tu_mdn=13333333333; 正确的例子：select * from test where tu_mdn='13333333333'
12) 1,<> 2,单独的>,<,(有时会用到，有时不会)
13) like "%_" 百分号在前
14) 表没分析
15) 单独引用复合索引里非第一位置的索引列
16) 字符型字段为数字时在where条件里不添加引号
17) 对索引列进行运算.需要建立函数索引
18) not in ,not exist
19) 当变量采用的是times变量，而表的字段采用的是date变量时.或相反情况
20) B-tree索引 is null不会走,is not null会走,位图索引 is null,is not null 都会走
21) 联合索引 is not null 只要在建立的索引列（不分先后）都会走, in null时 必须要和建立索引第一列一起使用,当建立索引第一位置条件是is null 时,其他建立索引的列可以是is null（但必须在所有列 都满足is null的时候）,或者=一个值； 当建立索引的第一位置是=一个值时,其他索引列可以是任何情况（包括is null =一个值）,以上两种情况索引都会走。其他情况不会走
