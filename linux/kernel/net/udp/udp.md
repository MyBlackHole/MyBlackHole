## 网络协议 - UDP 协议详解

> 基于TCP和UDP的协议非常广泛，所以也有必要对UDP协议进行详解。@pdai

+   [UDP概述](https://pdai.tech/md/develop/protocol/dev-protocol-udp.html#udp%E6%A6%82%E8%BF%B0)
+   [UDP特点](https://pdai.tech/md/develop/protocol/dev-protocol-udp.html#udp%E7%89%B9%E7%82%B9)
+   [UDP的首部格式](https://pdai.tech/md/develop/protocol/dev-protocol-udp.html#udp%E7%9A%84%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F)
    +   [UDP校验](https://pdai.tech/md/develop/protocol/dev-protocol-udp.html#udp%E6%A0%A1%E9%AA%8C)
+   [參考文章](https://pdai.tech/md/develop/protocol/dev-protocol-udp.html#%E5%8F%83%E8%80%83%E6%96%87%E7%AB%A0)

## UDP概述

UDP(User Datagram Protocol)即用户数据报协议，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OSI模型中，在第四层——传输层，处于IP协议的上一层。UDP用来支持那些需要在计算机之间传输数据的网络应用。包括网络视频会议系统在内的众多的客户/服务器模式的网络应用都需要使用UDP协议。UDP协议从问世至今已经被使用了很多年，虽然其最初的光彩已经被一些类似协议所掩盖，但是即使是在今天UDP仍然不失为一项非常实用和可行的网络传输层协议。UDP报文没有可靠性保证、顺序保证和流量控制字段等，可靠性较差。但是正因为UDP协议的控制选项较少，在数据传输过程中延迟小、数据传输效率高，适合对可靠性要求不高的应用程序，或者可以保障可靠性的应用程序，如DNS、TFTP、SNMP等。

## UDP特点

UDP提供不可靠服务，具有TCP所没有的优势：

+   **UDP无连接**，时间上不存在建立连接需要的时延。空间上，TCP需要在端系统中维护连接状态，需要一定的开销。此连接装入包括接收和发送缓存，拥塞控制参数和序号与确认号的参数。UCP不维护连接状态，也不跟踪这些参数，开销小。空间和时间上都具有优势。 举个例子：
    
    +   DNS如果运行在TCP之上而不是UDP，那么DNS的速度将会慢很多。
    +   HTTP使用TCP而不是UDP，是因为对于基于文本数据的Web网页来说，可靠性很重要。
    +   同一种专用应用服务器在支持UDP时，一定能支持更多的活动客户机。
+   **分组首部开销小**，TCP首部20字节，UDP首部8字节。
    
+   **UDP没有拥塞控制**，应用层能够更好的控制要发送的数据和发送时间，网络中的拥塞控制也不会影响主机的发送速率。某些实时应用要求以稳定的速度发送，能容 忍一些数据的丢失，但是不能允许有较大的时延（比如实时视频，直播等）
    
+   **UDP提供尽最大努力的交付，不保证可靠交付**。所有维护传输可靠性的工作需要用户在应用层来完成。没有TCP的确认机制、重传机制。如果因为网络原因没有传送到对端，UDP也不会给应用层返回错误信息
    
+   **UDP是面向报文的**，对应用层交下来的报文，添加首部后直接乡下交付为IP层，既不合并，也不拆分，保留这些报文的边界。对IP层交上来UDP用户数据报，在去除首部后就原封不动地交付给上层应用进程，报文不可分割，是UDP数据报处理的最小单位。 正是因为这样，UDP显得不够灵活，不能控制读写数据的次数和数量。比如我们要发送100个字节的报文，我们调用一次sendto函数就会发送100字节，对端也需要用recvfrom函数一次性接收100字节，不能使用循环每次获取10个字节，获取十次这样的做法。
    
+   **UDP常用一次性传输比较少量数据的网络应用**，如DNS,SNMP等，因为对于这些应用，若是采用TCP，为连接的创建，维护和拆除带来不小的开销。UDP也常用于多媒体应用（如IP电话，实时视频会议，流媒体等）数据的可靠传输对他们而言并不重要，TCP的拥塞控制会使他们有较大的延迟，也是不可容忍的
    
+   **UDP 支持一对一、一对多、多对一和多对多的交互通信**。
    

还要注意的是：

+   IP 数据报要经过互连网中许多路由器的存储转发；UDP 用户数据报是在**运输层的端到端抽象的逻辑信道中传送**的。

**UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。应用层交给 UDP 多长的报文，UDP 就照样发送，即一次发送一个报文**。

![](imgs/dev-network-udp-1.png)

## UDP的首部格式

在计算检验和时，**临时把“伪首部”和 UDP 用户数据报连接在一起。伪首部仅仅是为了计算检验和。**

![](imgs/dev-network-udp-2.png)

+   **源端口**: 占16位、源端口号。在需要对方回信时选用。不需要时可用全0。
+   **目的端口**: 占16位、目的端口号。这在终点交付报文时必须使用。
+   **长度**: 占16位、UDP用户数据报的长度,其最小值是8(仅有首部)。
+   **检验和**: 占16位、检测UDP用户数据报在传输中是否有错。有错就丢弃。

请注意，虽然在 UDP 之间的通信要用到其端口号，但由于 UDP 的通信是无连接的，因此不需要使用套接字。

### UDP校验

> UDP校验和的计算方法和IP数据报首部校验和的计算方法相似，都**使用二进制反码运算求和再取反**，但不同的是：**IP数据报的校验和之检验IP数据报和首部，但UDP的校验和是把首部和数据部分一起校验**。

发送方，首先是把全零放入校验和字段并且添加伪首部，然后把UDP数据报看成是由许多16位的子串连接起来，若UDP数据报的数据部分不是偶数个字节，则要在数据部分末尾增加一个全零字节（此字节不发送），接下来就按照二进制反码计算出这些16位字的和。将此和的二进制反码写入校验和字段。在接收方，把收到得UDP数据报加上伪首部（如果不为偶数个字节，还需要补上全零字节）后，按二进制反码计算出这些16位字的和。当无差错时其结果全为1,。否则就表明有差错出现，接收方应该丢弃这个UDP数据报。

下图是计算UDP校验和的例子：

![](imgs/dev-network-udp-3.png)

注意：

+   校验时，若UDP数据报部分的长度不是偶数个字节，则需要填入一个全0字节，但是次字节和伪首部一样，是不发送的。
+   如果UDP校验和校验出UDP数据报是错误的，可以丢弃，也可以交付上层，但是要附上错误报告，告诉上层这是错误的数据报。
+   通过伪首部，不仅可以检查源端口号，目的端口号和UDP用户数据报的数据部分，还可以检查IP数据报的源IP地址和目的地址。 这种差错检验的检错能力不强，但是简单，速度快。

## 參考文章

+   https://blog.csdn.net/dog250/article/details/6896949
+   https://blog.csdn.net/qq\_42196196/article/details/83956689
+   https://cloud.tencent.com/developer/article/1004554
+   https://blog.csdn.net/aa1928992772/article/details/85240358